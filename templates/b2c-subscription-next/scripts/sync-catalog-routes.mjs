import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const appRoot = path.resolve(__dirname, '..');
const repoRoot = path.resolve(appRoot, '..', '..');
const catalogRoot = path.join(repoRoot, 'modules', 'catalog');
const appApiRoot = path.join(appRoot, 'app', 'api');
const AUTO_HEADER = '/* AUTO-GENERATED. DO NOT EDIT. */';
const ALLOWED_METHODS = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE'];

const args = new Set(process.argv.slice(2));
const dryRun = args.has('--dry-run');

function fail(message) {
  console.error(message);
  process.exit(1);
}

function toPosix(value) {
  return value.split(path.sep).join('/');
}

function readJson(filePath) {
  return JSON.parse(fs.readFileSync(filePath, 'utf8'));
}

function findManifestFiles() {
  const rootManifest = path.join(catalogRoot, 'routes.manifest.json');
  if (fs.existsSync(rootManifest)) return [rootManifest];

  const modulesDir = path.join(catalogRoot, 'modules');
  if (!fs.existsSync(modulesDir)) return [];

  const manifestFiles = [];
  for (const entry of fs.readdirSync(modulesDir, { withFileTypes: true })) {
    if (!entry.isDirectory()) continue;
    const manifestPath = path.join(modulesDir, entry.name, 'routes.manifest.json');
    if (fs.existsSync(manifestPath)) {
      manifestFiles.push(manifestPath);
    }
  }
  return manifestFiles;
}

function normalizeRoutes(manifestJson, manifestPath) {
  const base = path.dirname(manifestPath);
  const rawRoutes = Array.isArray(manifestJson)
    ? manifestJson
    : Array.isArray(manifestJson.routes)
      ? manifestJson.routes
      : [];

  if (!Array.isArray(rawRoutes) || rawRoutes.length === 0) {
    return [];
  }

  return rawRoutes.map((route, index) => {
    if (!route || typeof route !== 'object') {
      fail(`Invalid route entry at ${manifestPath} index ${index}`);
    }

    const routePath = String(route.path ?? route.route ?? '').trim().replace(/^\/+|\/+$/g, '');
    const sourceRaw = String(route.source ?? route.sourcePath ?? route.catalogSource ?? '').trim();
    const methodsRaw = Array.isArray(route.methods) ? route.methods : [];

    if (!routePath) {
      fail(`Missing route path at ${manifestPath} index ${index}`);
    }

    if (!sourceRaw) {
      fail(`Missing route source at ${manifestPath} index ${index}`);
    }

    if (methodsRaw.length === 0) {
      fail(`Missing methods at ${manifestPath} index ${index}`);
    }

    const methods = methodsRaw
      .map((m) => String(m).toUpperCase())
      .filter((m) => ALLOWED_METHODS.includes(m));

    if (methods.length === 0) {
      fail(`No valid HTTP methods at ${manifestPath} index ${index}`);
    }

    const source = sourceRaw.startsWith('.')
      ? toPosix(path.relative(appRoot, path.resolve(base, sourceRaw)))
      : sourceRaw;

    return { routePath, source, methods };
  });
}

function buildRouteContent(source, methods) {
  const exportList = methods.join(', ');
  return `${AUTO_HEADER}\nexport { ${exportList} } from "${source}";\n`;
}

function collectAutoGeneratedRouteFiles(dirPath, acc = []) {
  if (!fs.existsSync(dirPath)) return acc;

  for (const entry of fs.readdirSync(dirPath, { withFileTypes: true })) {
    const abs = path.join(dirPath, entry.name);
    if (entry.isDirectory()) {
      collectAutoGeneratedRouteFiles(abs, acc);
      continue;
    }

    if (entry.isFile() && entry.name === 'route.ts') {
      const content = fs.readFileSync(abs, 'utf8');
      if (content.startsWith(AUTO_HEADER)) {
        acc.push(abs);
      }
    }
  }
  return acc;
}

if (!fs.existsSync(catalogRoot)) {
  fail(`Missing module-catalog submodule: ${catalogRoot}`);
}

const manifestFiles = findManifestFiles();
if (manifestFiles.length === 0) {
  fail('No route manifests found. Expected modules/catalog/routes.manifest.json or modules/catalog/modules/*/routes.manifest.json');
}

const routeEntries = [];
for (const manifestPath of manifestFiles) {
  const manifestJson = readJson(manifestPath);
  routeEntries.push(...normalizeRoutes(manifestJson, manifestPath));
}

const desired = new Map();
for (const entry of routeEntries) {
  const routeFile = path.join(appApiRoot, entry.routePath, 'route.ts');
  if (desired.has(routeFile)) {
    fail(`Duplicate route path detected: ${entry.routePath}`);
  }
  desired.set(routeFile, buildRouteContent(entry.source, entry.methods));
}

const created = [];
const updated = [];
const deleted = [];

for (const [filePath, content] of desired.entries()) {
  if (dryRun) continue;

  fs.mkdirSync(path.dirname(filePath), { recursive: true });

  if (!fs.existsSync(filePath)) {
    fs.writeFileSync(filePath, content, 'utf8');
    created.push(toPosix(path.relative(repoRoot, filePath)));
    continue;
  }

  const current = fs.readFileSync(filePath, 'utf8');
  if (current !== content) {
    fs.writeFileSync(filePath, content, 'utf8');
    updated.push(toPosix(path.relative(repoRoot, filePath)));
  }
}

const existingAutoRoutes = collectAutoGeneratedRouteFiles(appApiRoot);
for (const existingFile of existingAutoRoutes) {
  if (desired.has(existingFile)) continue;
  if (dryRun) continue;

  fs.unlinkSync(existingFile);
  deleted.push(toPosix(path.relative(repoRoot, existingFile)));
}

console.log('[routes:sync] created');
for (const file of created) console.log(`- ${file}`);
console.log('[routes:sync] updated');
for (const file of updated) console.log(`- ${file}`);
console.log('[routes:sync] deleted');
for (const file of deleted) console.log(`- ${file}`);
